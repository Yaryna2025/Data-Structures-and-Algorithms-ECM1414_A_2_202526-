=======================================
EVENT PLANNER PSEUDOCODE (WITH TIME CONSTRAINT)
=======================================

# 1. Handiling of an input
FUNCTION read_input_file(filename):
    activities = empty list

    open filename as file
        # Checks how many activities we have by reading the given file.
        n = read first line as integer
        # By using map we do a shortcut to do it one time, by coverting several strings to integers.
        max_time, max_budget = read second line and convert both to integers

        repeat n times:
            # Reads lines and skips if line is empty.
            line = read next line and strip whitespace

            if line is empty:
                skip it and continue

            # By splitting line into parts we can skip the lines that can lead code to failure.
            parts = split line by spaces
            # Number four refers to 4 parts: name, time, cost and enjoyment.
            if parts has less than 4 values:
                print "Skipping invalid line"
                skip it and continue

            name = parts[0]
            time_required = int(parts[1])
            cost = int(parts[2])
            enjoyment = int(parts[3])

            # For more convinient use, we store activity as dictionary.
            activity = {"name": name, "time": time_required, "cost": cost, "enjoyment": enjoyment}
            add activity to activities

    close file
    return activities, max_time, max_budget


# 2. Brute-force algorithm
FUNCTION brute_force(activities, max_time):
    # We try to find the best combination of given activities.
    best_activities = empty list
    max_enjoyment = 0

    # Check every possible number of our given activities.
    for subset_size from 0 to length(activities):
        # By using Python Library itertools, we generate all possible combinations of length of s,
        # which is as stated above from 0 up to len(activities).
        for each subset of activities with size subset_size:
            # Check that we only consider subsets that are suitable for available time.
            total_time = sum of activity.time for activity in subset

            if total_time is within max_time:
                # Calculate the total enjoyment of the current subset.
                total_enjoyment = sum of activity.enjoyment for activity in subset

                if total_enjoyment is better than max_enjoyment:
                    # Update previously stated max_enjoyment and best_activities.
                    max_enjoyment = total_enjoyment
                    best_activities = subset

    return best_activities, max_enjoyment


# 3. Dynamic programming algorithm
FUNCTION dynamic_programming(activities, max_time):
    n = length(activities)

    # Create the table in 2D in which we will store achievable maximum enjoyment.
    # max_enjoyment_table[i][t] = best enjoyment using first i activities with time limit t.
    max_enjoyment_table = empty list
    for i from 0 to n:
        create a new row with max_time + 1 zeros
        add this row to max_enjoyment_table

    for i from 1 to n:
        activity = activities[i - 1]

        for t from 0 to max_time:
            # Check if our activity is suitable for left time.
            # Check what happends if it fits.
            if activity.time fits in t:
                # We have then two choices: skip the activity or include it.
                # Skip the current activity.
                skip_activity = max_enjoyment_table[i - 1][t]

                # Include the current activity.
                include_activity = max_enjoyment_table[i - 1][t - activity.time] + activity.enjoyment

                # Choose the option with higher total enjoyment.
                max_enjoyment_table[i][t] = max(skip_activity, include_activity)
            else:
                # Include the possibility when activity does not fit.
                max_enjoyment_table[i][t] = max_enjoyment_table[i - 1][t]

    max_enjoyment = max_enjoyment_table[n][max_time]

    t = max_time
    best_activities = empty list

    # We loop from end to beginning to see which activities contributes to the maximum enjoyment.
    for i from n down to 1:
        # Check if this activity was included in possible solution.
        if max_enjoyment_table[i][t] is different from max_enjoyment_table[i - 1][t]:
            # Get the activity which has maximum enjoyment.
            activity = activities[i - 1]
            add activity to best_activities
            # Reduce remaining time by this activity's time.
            t = t - activity.time

    # Fix the order as we iterated from the end.
    reverse best_activities
    return best_activities, max_enjoyment


# 4. Print of the results
FUNCTION results(label, best_activities, max_enjoyment, exec_time):
    print a header using label

    # Check if any activities where selected.
    if best_activities is not empty:
        print "Selected Activities:"
        for each activity in best_activities:
            print activity name, time, cost, enjoyment
    else:
        print "No activities were selected."

    total_time_used = sum of activity.time for activity in best_activities
    total_cost_used = sum of activity.cost for activity in best_activities

    print total enjoyment, total time used, total cost, and execution time


# 5. Main execution
FUNCTION event_planner_summary():
    loop forever:
        ask user for input size (small/medium/large) or 'e' to exit
        convert input to lowercase

        if input is 'e':
            stop the program

        if input is not one of small/medium/large:
            print an error message
            continue

        build filename pointing to Input_Files/input_<size>.txt (relative to the script)

        if filename does not exist:
            print "Input file is not found"
            continue

        # Read the activities.
        activities, max_time, max_budget = read_input_file(filename)

        print a title + show chosen file, max_time, max_budget

        # Brute-force
        start timer
        best_activities, max_enjoyment = brute_force(activities, max_time)
        # Calculate how much time did the brute-force algorithm take.
        stop timer
        call results for brute force

        # Dynamic Programming
        start timer
        best_activities, max_enjoyment = dynamic_programming(activities, max_time)
        # Calculate how much time did the dynamic-programming algorithm take.
        stop timer
        call results for dynamic programming


MAIN:
    if this file is being run directly:
        call event_planner_summary()
